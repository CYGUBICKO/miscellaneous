---
title: 'Split multiple response entry column(s) in R'
author: "Steve Cygu ([cygubicko@gmail.com](mailto:cygubicko@gmail.com))"
date: "2019 Feb 21 (Thu)"
output:
  html_document:
   code_folding: hide
   number_sections: yes
   toc: yes
   toc_depth: 5
   toc_float: yes
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE
	, warning = FALSE
	, message = FALSE
	, fig.width = 10
	, fig.height = 10
	, results = "asis")
options(width = 12)
```

# Setup

We begin by loading the required packages. If you don't have the packages installed, use `install.packages("package_name")`.

```{r, echo = TRUE}
library(DT)
library(dplyr)
```


# Problem

In many data collection software, multiple response questions' selections (respondent can choose more than one option) are usually stored in a single cell separated with some characters. This problem is mostly common in _ODK_ and other _ODK_ based tools or even Google Forms. In addition, a more general problem could be creating columns from a single column of a dataframe based on some pattern.

To demonstrate how we go about this, we use [social media survey data](https://github.com/CYGUBICKO/miscellaneous/tree/master/datasets) in which reposndents were asked which social media they use. Let us take a look at the variables.

```{r}
desc <- read.csv("../datasets/multi_resp_desc.csv")
datatable(desc, rownames = FALSE)
```

In this example, the respondents could have selected more than one social media platforms (see **smedia\_used**). The selected oprions are seperated using "," and our aim is to create additional variables to hold each of the selected responses. Let us take a look at the data

```{r, echo = TRUE}
smedia_df <- read.csv("../datasets/multi_response.csv")
datatable(head(smedia_df), rownames = FALSE)
```

Some of the ways to solve thus problem may include:

* Split columns in excel

* Use R functions

In this post, we will show a step by step guide on how to write a R function which will be able to do the job.


# R way

As mentioned above, we are going to demonstrate this using **smedia\_used** variable. We would therefore ask ourselves how much information do we have and best can use such?

|What we see | What R will understand | Comment |
|------- | ------- | -------------|
|","     | pattern | This can be any pattern ("-", "space",...) dependeing on the plattform/problem.| 
|Individual entries in **smedia\_used** | Number of new variables to create | Number of new variables to be created equals max(number of entries).|
----------------------------------------------------------------------
 

First we need to understand how pattern matching and regular expressions work in R. You can find some help online but I would recommend [Regular Expressions in R](https://rstudio-pubs-static.s3.amazonaws.com/74603_76cd14d5983f47408fdf0b323550b846.html) or [Pattern Matching and Replacement](http://astrostatistics.psu.edu/su07/R/html/base/html/grep.html) as a starting point.

We need to count the number of selections in **smedia\_used** based on the pattern ",".

```{r, echo = TRUE}
countFunc <- function(x, pattern){
	nselect <- sapply(gregexpr(pattern, x), length) + 1
	return(nselect)
}
```
* _x_ - input variable (could be multiple response)
* _pattern_ - what separates the entries. Could be ",", "_" ....
* _gregexpr()_ - Searches for the pattern and returns the position if TRUE.
* _sapply_ - tells R to 'repeatedly' search for the pattern and do something - _length_.
* _length_ - what _sapply_ does. Counts the number of patterns found.
* _+1_ - counting only happens if there is more than one entry. This accounts for first selection.

Let us test the `countFunc`.

```{r, echo = TRUE}
test_vec <- c("first, second, third", "fourth", "second, fifth")
pattern <- ","
countFunc(test_vec, pattern)
```

```{r, echo = TRUE}
pattern <- ","
smedia_df <- (smedia_df
	%>% mutate(num_select = sum(grepl(pattern, smedia_used, ignore.case = TRUE)) + 1)
)
```

* `grepl()` above looks for the pattern and then returns _TRUE_ or _FALSE_. We then sum to count the number of occurances and then add $1$ to take care of at least a single selection. Let us take a look:

```{r, echo = TRUE}
count_df <- (smedia_df
	%>% select(smedia_used, num_select)
	%>% datatable(rownames = FALSE)
)
count_df
```
